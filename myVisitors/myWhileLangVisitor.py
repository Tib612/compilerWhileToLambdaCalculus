from gen.whileLangVisitor import whileLangVisitor
from gen.whileLangParser import whileLangParser
from myVisitors.codePrinter import codePrinter

# codePrinter is a helper function that keep the code clean.
cp = codePrinter()

# The below function let you choose whether  you want to use syntaxic sugar or not.
cp.setHumanReadable(False)


# This class is used to visit all branches of the tree.
# It implements the visitor design pattern.
# It inherits the "whileLangVisitor" class that was generated by ANTLR4
# Each "visit..." function visit a part of the tree recursively.

class myWhileLangVisitor(whileLangVisitor):

    def __init__(self,nbVar,outputfile=""):
        self.nbVar = nbVar
        self.outputfile = outputfile

    # find whether or not a expression need the environment
    def needState(self,ctx):
        return "var" in ctx.getText()

    def visitProg(self, ctx: whileLangParser.ProgContext):
        #print("visitProg")
        res = ""
        if ctx.instr():
            res = self.visitInstr(ctx.instr())[0]
            res = r"(\v. (\s. " + cp.get() + " (" + res + " s) "+cp.int(1)+" ) (" + cp.init() + " " + cp.int(int(str(self.nbVar))) + " v)) 0"
        with open(self.outputfile, "w") as myfile:
            myfile.write(res)

    def visitQuote(self, ctx: whileLangParser.QuoteContext):
        if ctx.LPAR():
            return self.visitQuote(ctx.quote())
        elif ctx.QUOTE():
            return self.visitA(ctx.a())
        return "problem Quote"

    def visitA(self, ctx:whileLangParser.AContext):
        #print("visitA")
        if ctx.NUM():
            return cp.int(int(ctx.NUM().__str__()))
        elif ctx.NIL():
            return cp.false()

        return "problem A"

    def visitInstr(self, ctx: whileLangParser.InstrContext, needLBRA=None):
        #print("in: "+str(needLBRA))
        #print("visitInstr")

        ctx = self.checkForList(ctx)
        txt = ""

        if needLBRA is None:
            needLBRA = []

        if ctx.LPAR():
            txt, needLBRA = self.visitInstr(ctx.instr(),needLBRA)
        elif ctx.ATTR():

            s0 = " "
            s1 = " "
            if self.needState(ctx.expr()):
                s0 = " ("
                s1 = " s)"
            txt = r"(\s." + self.visitVar(ctx.var(), True) + s0 + self.visitExpr(ctx.expr())+s1+")"

        elif ctx.SEMICOLON():

            txt0 = self.visitInstr(ctx.instr(0))[0]
            needLBRA.append(txt0)
            txt1, list = self.visitInstr(ctx.instr(1), needLBRA)
            txt = r"(\s. {} ({} s))".format(txt1,needLBRA.pop(-1))

        elif ctx.WHILE():
            #print("in while")
            condition = r"(\s." + cp.booleanEval() + " (" + self.visitExpr(ctx.expr()) +"s))"
            txt = r" (\s. "+cp.p_while() +" "+ condition + " " + self.visitInstr(ctx.instr())[0]+" s)"


        return txt, needLBRA

    def visitVar(self, ctx: whileLangParser.VarContext, setter=False):
        #print("visitVar")
        if ctx.var():
            return self.visitVar(ctx.var(),setter)
        elif ctx.NUM():
            if setter:
                return cp.set() + " s " + cp.int(int(ctx.NUM().__str__()))
            else:
                return cp.get() + " s " + cp.int(int(ctx.NUM().__str__()))
        return "problem Var"


    def visitExpr(self, ctx: whileLangParser.ExprContext):
        #print("visitExpr")

        ctx = self.checkForList(ctx)

        s1 = " "
        txt = "("
        if self.needState(ctx):
            txt = r"(\s."
            s1 = " s "

        if ctx.var():
            return r"(\s." + self.visitVar(ctx.var()) +")"
        elif ctx.quote():
            return self.visitQuote(ctx.quote())
        elif ctx.LPAR():
            return self.visitExpr(ctx.expr())
        elif ctx.HD():
            return txt + self.visitExpr(ctx.expr()) + s1 + cp.true() + ")"
        elif ctx.TL():
            return txt + self.visitExpr(ctx.expr()) + s1 + cp.false() + ")"

        s1 = ") ("
        s2 = "))"
        if self.needState(ctx.expr(0)):
            s1 = " s) ("
        if self.needState(ctx.expr(1)):
            s2 = " s))"

        if ctx.CONS():
            return txt + cp.cons() + "(" +self.visitExpr(ctx.expr(0)) + s1 + self.visitExpr(ctx.expr(1))+ s2
        elif ctx.ISEQUAL():
            return txt + cp.equalAny() + " (" + self.visitExpr(ctx.expr(0)) + s1 + self.visitExpr(ctx.expr(1)) + s2
        elif ctx.PLUS():
            return txt + cp.add() + " (" +self.visitExpr(ctx.expr(0))+ s1 +self.visitExpr(ctx.expr(1)) + s2
        elif ctx.MINUS():
            return txt + cp.sub() + " (" +self.visitExpr(ctx.expr(0))+ s1 +self.visitExpr(ctx.expr(1)) + s2
        elif ctx.MULT():
            return txt + cp.mult() + " (" +self.visitExpr(ctx.expr(0))+ s1 +self.visitExpr(ctx.expr(1)) + s2
        return "problem Expr"

    # helper function
    # sometimes context are list of one object. I need to extract it.
    def checkForList(self,ctx):
        if isinstance(ctx, list):
            return ctx[0]
        return ctx
